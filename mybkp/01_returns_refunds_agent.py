"""
Standalone Strands Agent: returns_refunds_agent
Generated by AgentCore MCP Server

Integrations:
- Memory: Disabled
- Gateway: Disabled
- Knowledge Base: Enabled
"""

import os
from strands import Agent, tool
from strands.models import BedrockModel
from strands_tools import retrieve
from strands_tools import current_time
from datetime import datetime

# Constants
MODEL_ID = "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
REGION = "us-west-2"
SESSION_ID = "default-session"
ACTOR_ID = "default-actor"

# Model configuration
bedrock_model = BedrockModel(model_id=MODEL_ID, temperature=0.3)

# ============================================================================
# KNOWLEDGE BASE CONFIGURATION
# ============================================================================

kb_id = os.environ.get("KNOWLEDGE_BASE_ID", "XAJMXADZWS")
print(f"âœ“ Knowledge Base ID: {kb_id}")

# System prompt
system_prompt = f"""You are a helpful returns and refunds assistant. Help customers check return eligibility, calculate refunds, and understand policies. Use the retrieve tool to access Amazon return policy documents for accurate information. Be friendly and accurate.

When using the retrieve tool, always pass these parameters:
- knowledgeBaseId: {kb_id}
- region: {REGION}
- text: the search query"""

# Custom tool definitions
@tool

def check_return_eligibility(purchase_date: str, category: str, condition: str = "unopened") -> dict:
    """Check if an item can be returned.
    
    Args:
        purchase_date: Purchase date in YYYY-MM-DD format
        category: Product category (electronics, clothing, books, etc.)
        condition: Item condition (unopened, opened, damaged)
    """
    try:
        purchase_dt = datetime.strptime(purchase_date, "%Y-%m-%d")
        days_since_purchase = (datetime.now() - purchase_dt).days
        
        # Return windows by category
        return_windows = {
            "electronics": 30,
            "clothing": 30,
            "books": 30,
            "furniture": 30,
            "grocery": 30,
            "default": 30
        }
        
        window = return_windows.get(category.lower(), return_windows["default"])
        
        if days_since_purchase > window:
            return {
                "eligible": False,
                "reason": f"Return window of {window} days has expired ({days_since_purchase} days since purchase)",
                "days_remaining": 0
            }
        
        if condition.lower() == "damaged" and days_since_purchase > 7:
            return {
                "eligible": False,
                "reason": "Damaged items must be reported within 7 days",
                "days_remaining": 0
            }
        
        return {
            "eligible": True,
            "reason": "Item is within return window",
            "days_remaining": window - days_since_purchase
        }
    except Exception as e:
        return {
            "eligible": False,
            "reason": f"Error checking eligibility: {str(e)}",
            "days_remaining": 0
        }

@tool
def calculate_refund_amount(original_price: float, condition: str, return_reason: str, shipping_cost: float = 0.0) -> dict:
    """Calculate refund amount.
    
    Args:
        original_price: Original purchase price
        condition: Item condition (unopened, opened, damaged)
        return_reason: Reason for return (defective, wrong_item, changed_mind, etc.)
        shipping_cost: Original shipping cost paid
    """
    try:
        refund_amount = original_price
        restocking_fee = 0.0
        shipping_refund = shipping_cost
        
        # Restocking fees for opened items
        if condition.lower() == "opened" and return_reason.lower() == "changed_mind":
            restocking_fee = original_price * 0.15  # 15% restocking fee
            refund_amount -= restocking_fee
        
        # Reduced refund for damaged items (customer fault)
        if condition.lower() == "damaged" and return_reason.lower() not in ["defective", "wrong_item"]:
            refund_amount *= 0.5  # 50% refund for customer-damaged items
        
        # Full refund including shipping for defective/wrong items
        if return_reason.lower() in ["defective", "wrong_item"]:
            refund_amount = original_price + shipping_cost
            shipping_refund = shipping_cost
        else:
            shipping_refund = 0.0  # No shipping refund for change of mind
        
        return {
            "refund_amount": round(refund_amount, 2),
            "original_price": original_price,
            "restocking_fee": round(restocking_fee, 2),
            "shipping_refund": round(shipping_refund, 2),
            "total_refund": round(refund_amount, 2),
            "breakdown": f"Original: ${original_price:.2f}, Restocking Fee: -${restocking_fee:.2f}, Shipping: ${shipping_refund:.2f}"
        }
    except Exception as e:
        return {
            "refund_amount": 0.0,
            "error": f"Error calculating refund: {str(e)}"
        }

@tool
def format_policy_response(policy_text: str, customer_question: str = "") -> str:
    """Format policy information for customers.
    
    Args:
        policy_text: Raw policy text from knowledge base
        customer_question: Original customer question for context
    """
    try:
        # Add friendly formatting
        formatted = "ðŸ“‹ **Return Policy Information**\n\n"
        
        if customer_question:
            formatted += f"Regarding your question: *{customer_question}*\n\n"
        
        # Clean up and format the policy text
        lines = policy_text.strip().split('\n')
        for line in lines:
            line = line.strip()
            if line:
                # Add bullet points for list items
                if line.startswith('-') or line.startswith('â€¢'):
                    formatted += f"  {line}\n"
                else:
                    formatted += f"{line}\n\n"
        
        formatted += "\nðŸ’¡ **Need Help?** If you have more questions, just ask!"
        
        return formatted
    except Exception as e:
        return f"Error formatting policy: {str(e)}\n\nRaw policy text:\n{policy_text}"


def run_agent(user_input: str, session_id: str = SESSION_ID, actor_id: str = ACTOR_ID):
    """Run the agent with user input"""
    
    # Build tools list
    custom_tools = [retrieve, current_time, check_return_eligibility, calculate_refund_amount, format_policy_response]
    
    # Create agent
    agent = Agent(
        model=bedrock_model,
        tools=custom_tools,
        system_prompt=system_prompt
    )
    
    response = agent(user_input)
    return response.message["content"][0]["text"]

if __name__ == "__main__":
    # Example usage
    user_query = "Hello, how can you help me?"
    result = run_agent(user_query)
    print("\n" + "="*80)
    print("AGENT RESPONSE:")
    print("="*80)
    print(result)
