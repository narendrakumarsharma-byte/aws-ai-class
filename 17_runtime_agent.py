"""
AgentCore Runtime Agent: returns_agent_runtime
Generated by AgentCore MCP Server

This agent is ready to deploy to AgentCore Runtime with:
1. BedrockAgentCoreApp entrypoint
2. Memory integration
3. Gateway tools
4. Knowledge Base access
5. Custom tools for returns processing
"""

import os
import json
from bedrock_agentcore.runtime import BedrockAgentCoreApp
from strands import Agent, tool
from strands.models import BedrockModel
from strands_tools import retrieve
from strands_tools import current_time
from strands.tools.mcp import MCPClient
from mcp.client.streamable_http import streamablehttp_client
import requests
from bedrock_agentcore.memory.integrations.strands.config import AgentCoreMemoryConfig, RetrievalConfig
from bedrock_agentcore.memory.integrations.strands.session_manager import AgentCoreMemorySessionManager
from datetime import datetime

# Constants
MODEL_ID = "us.anthropic.claude-sonnet-4-5-20250929-v1:0"
REGION = "us-west-2"
SESSION_ID = "default-session"
ACTOR_ID = "default-actor"

# Initialize app
app = BedrockAgentCoreApp()

# Load configuration from environment or config files
def load_config():
    """Load configuration from files if available"""
    config = {}
    
    # Try to load from config files (for local testing)
    config_files = {
        'memory': 'memory_config.json',
        'gateway': 'gateway_config.json',
        'cognito': 'cognito_config.json',
        'kb': 'kb_config.json'
    }
    
    for config_name, config_file in config_files.items():
        try:
            with open(config_file) as f:
                config[config_name] = json.load(f)
        except FileNotFoundError:
            pass
    
    return config

# Load config at module level for local testing
config = load_config()

# Get KB ID from config or environment
kb_id = os.environ.get("KNOWLEDGE_BASE_ID")
if not kb_id and config.get('kb'):
    kb_id = config['kb'].get('knowledge_base_id', 'YOUR_KB_ID_HERE')
else:
    kb_id = kb_id or "YOUR_KB_ID_HERE"

print(f"âœ“ Knowledge Base ID: {kb_id}")

# ============================================================================
# CUSTOM TOOLS
# ============================================================================

@tool
def check_return_eligibility(purchase_date: str, category: str, condition: str = "unopened") -> dict:
    """Check if an item can be returned.
    
    Args:
        purchase_date: Purchase date in YYYY-MM-DD format
        category: Product category (electronics, clothing, books, etc.)
        condition: Item condition (unopened, opened, damaged)
    """
    try:
        purchase_dt = datetime.strptime(purchase_date, "%Y-%m-%d")
        days_since_purchase = (datetime.now() - purchase_dt).days
        
        # Return windows by category
        return_windows = {
            "electronics": 30,
            "clothing": 30,
            "books": 30,
            "furniture": 30,
            "grocery": 30,
            "default": 30
        }
        
        window = return_windows.get(category.lower(), return_windows["default"])
        
        if days_since_purchase > window:
            return {
                "eligible": False,
                "reason": f"Return window of {window} days has expired ({days_since_purchase} days since purchase)",
                "days_remaining": 0
            }
        
        if condition.lower() == "damaged" and days_since_purchase > 7:
            return {
                "eligible": False,
                "reason": "Damaged items must be reported within 7 days",
                "days_remaining": 0
            }
        
        return {
            "eligible": True,
            "reason": "Item is within return window",
            "days_remaining": window - days_since_purchase
        }
    except Exception as e:
        return {
            "eligible": False,
            "reason": f"Error checking eligibility: {str(e)}",
            "days_remaining": 0
        }

@tool
def calculate_refund_amount(original_price: float, condition: str, return_reason: str, shipping_cost: float = 0.0) -> dict:
    """Calculate refund amount.
    
    Args:
        original_price: Original purchase price
        condition: Item condition (unopened, opened, damaged)
        return_reason: Reason for return (defective, wrong_item, changed_mind, etc.)
        shipping_cost: Original shipping cost paid
    """
    try:
        refund_amount = original_price
        restocking_fee = 0.0
        shipping_refund = shipping_cost
        
        # Restocking fees for opened items
        if condition.lower() == "opened" and return_reason.lower() == "changed_mind":
            restocking_fee = original_price * 0.15  # 15% restocking fee
            refund_amount -= restocking_fee
        
        # Reduced refund for damaged items (customer fault)
        if condition.lower() == "damaged" and return_reason.lower() not in ["defective", "wrong_item"]:
            refund_amount *= 0.5  # 50% refund for customer-damaged items
        
        # Full refund including shipping for defective/wrong items
        if return_reason.lower() in ["defective", "wrong_item"]:
            refund_amount = original_price + shipping_cost
            shipping_refund = shipping_cost
        else:
            shipping_refund = 0.0  # No shipping refund for change of mind
        
        return {
            "refund_amount": round(refund_amount, 2),
            "original_price": original_price,
            "restocking_fee": round(restocking_fee, 2),
            "shipping_refund": round(shipping_refund, 2),
            "total_refund": round(refund_amount, 2),
            "breakdown": f"Original: ${original_price:.2f}, Restocking Fee: -${restocking_fee:.2f}, Shipping: ${shipping_refund:.2f}"
        }
    except Exception as e:
        return {
            "refund_amount": 0.0,
            "error": f"Error calculating refund: {str(e)}"
        }

@tool
def format_policy_response(policy_text: str, customer_question: str = "") -> str:
    """Format policy information for customers.
    
    Args:
        policy_text: Raw policy text from knowledge base
        customer_question: Original customer question for context
    """
    try:
        # Add friendly formatting
        formatted = "ðŸ“‹ **Return Policy Information**\n\n"
        
        if customer_question:
            formatted += f"Regarding your question: *{customer_question}*\n\n"
        
        # Clean up and format the policy text
        lines = policy_text.strip().split('\n')
        for line in lines:
            line = line.strip()
            if line:
                # Add bullet points for list items
                if line.startswith('-') or line.startswith('â€¢'):
                    formatted += f"  {line}\n"
                else:
                    formatted += f"{line}\n\n"
        
        formatted += "\nðŸ’¡ **Need Help?** If you have more questions, just ask!"
        
        return formatted
    except Exception as e:
        return f"Error formatting policy: {str(e)}\n\nRaw policy text:\n{policy_text}"

# ============================================================================
# GATEWAY HELPER FUNCTIONS
# ============================================================================

def get_cognito_token_with_scope(client_id, client_secret, discovery_url, scope):
    """Get Cognito bearer token with a specific OAuth scope"""
    try:
        # Extract token endpoint from discovery URL
        discovery_response = requests.get(discovery_url, timeout=10)
        discovery_response.raise_for_status()
        token_endpoint = discovery_response.json()['token_endpoint']
        
        # Get token using client credentials flow
        response = requests.post(
            token_endpoint,
            data={
                'grant_type': 'client_credentials',
                'client_id': client_id,
                'client_secret': client_secret,
                'scope': scope
            },
            headers={'Content-Type': 'application/x-www-form-urlencoded'},
            timeout=10
        )
        
        response.raise_for_status()
        return response.json()["access_token"]
    except Exception as e:
        print(f"Error getting Cognito token: {e}")
        raise

def create_mcp_client():
    """Create MCP client for gateway access"""
    try:
        # Get from environment first, then fall back to config
        gateway_url = os.environ.get("GATEWAY_URL")
        cognito_client_id = os.environ.get("COGNITO_CLIENT_ID")
        cognito_client_secret = os.environ.get("COGNITO_CLIENT_SECRET")
        cognito_discovery_url = os.environ.get("COGNITO_DISCOVERY_URL")
        
        # Fall back to config files if environment variables not set
        if not gateway_url and config.get('gateway'):
            gateway_url = config['gateway'].get('gateway_url')
        if not cognito_client_id and config.get('cognito'):
            cognito_client_id = config['cognito'].get('client_id')
            cognito_client_secret = config['cognito'].get('client_secret')
            cognito_discovery_url = config['cognito'].get('discovery_url')
        
        if not all([gateway_url, cognito_client_id, cognito_client_secret, cognito_discovery_url]):
            print("Warning: Gateway configuration incomplete")
            return None
        
        # Get scopes from config or use default
        if config.get('cognito') and 'scopes' in config['cognito']:
            oauth_scopes = ' '.join(config['cognito']['scopes'])
        else:
            oauth_scopes = os.environ.get("OAUTH_SCOPES", "returns-agent-api/read returns-agent-api/write")
        
        token = get_cognito_token_with_scope(
            cognito_client_id,
            cognito_client_secret,
            cognito_discovery_url,
            oauth_scopes
        )
        
        return MCPClient(
            lambda: streamablehttp_client(
                gateway_url,
                headers={"Authorization": f"Bearer {token}"},
            )
        )
    except Exception as e:
        print(f"Warning: Failed to create MCP client: {e}")
        return None

# System prompt
system_prompt = f"""Production returns assistant with full memory and gateway capabilities. Use the retrieve tool to access Amazon return policy documents for accurate information.

When using the retrieve tool, always pass these parameters:
- knowledgeBaseId: {kb_id}
- region: {REGION}
- text: the search query
- Gateway tools for external operations
- Customer conversation history and preferences through memory"""

@app.entrypoint
def invoke(payload, context=None):
    """AgentCore Runtime entrypoint"""
    try:
        print(f"Invocation started with payload: {payload}")
        
        # Initialize model inside the function
        bedrock_model = BedrockModel(model_id=MODEL_ID, temperature=0.3)
        
        # Get memory ID from environment or config
        memory_id = os.environ.get("MEMORY_ID")
        if not memory_id and config.get('memory'):
            memory_id = config['memory'].get('memory_id')
        
        if not memory_id:
            return {"error": "MEMORY_ID environment variable is required"}
        
        # Get session and actor IDs
        session_id = context.session_id if context else SESSION_ID
        actor_id = payload.get("actor_id", ACTOR_ID)
        
        print(f"Using memory_id: {memory_id}, actor_id: {actor_id}, session_id: {session_id}")
        
        # Configure memory with retrieval settings
        agentcore_memory_config = AgentCoreMemoryConfig(
            memory_id=memory_id,
            session_id=session_id,
            actor_id=actor_id,
            retrieval_config={
                f"app/{actor_id}/semantic": RetrievalConfig(top_k=3),
                f"app/{actor_id}/preferences": RetrievalConfig(top_k=3),
                f"app/{actor_id}/{session_id}/summary": RetrievalConfig(top_k=2),
            }
        )
        
        session_manager = AgentCoreMemorySessionManager(
            agentcore_memory_config=agentcore_memory_config,
            region_name=REGION
        )
        
        print("Memory session manager configured")
        
        # Build custom tools list
        custom_tools = [retrieve, current_time, check_return_eligibility, calculate_refund_amount, format_policy_response]
        
        # Try to create MCP client for gateway tools
        mcp_client = create_mcp_client()
        
        if mcp_client:
            try:
                print("Attempting to load gateway tools...")
                # Keep MCP client active during agent execution
                with mcp_client:
                    # Get gateway tools from MCP client
                    gateway_tools = list(mcp_client.list_tools_sync())
                    print(f"Loaded {len(gateway_tools)} gateway tool(s)")
                    
                    # Create agent with all tools
                    agent = Agent(
                        model=bedrock_model,
                        tools=custom_tools + gateway_tools,
                        system_prompt=system_prompt,
                        session_manager=session_manager
                    )
                    
                    user_input = payload.get("prompt", "")
                    print(f"Processing user input: {user_input}")
                    response = agent(user_input)
                    return response.message["content"][0]["text"]
            except Exception as e:
                print(f"Warning: Failed to use gateway tools: {e}")
                import traceback
                traceback.print_exc()
                # Fall back to agent without gateway tools
        else:
            print("Gateway not configured, running without gateway tools")
        
        # Create agent without gateway tools (fallback)
        agent = Agent(
            model=bedrock_model,
            tools=custom_tools,
            system_prompt=system_prompt,
            session_manager=session_manager
        )
        
        user_input = payload.get("prompt", "")
        print(f"Processing user input: {user_input}")
        response = agent(user_input)
        return response.message["content"][0]["text"]
    
    except Exception as e:
        error_msg = f"Agent invocation failed: {str(e)}"
        print(error_msg)
        import traceback
        traceback.print_exc()
        return {"error": error_msg}

if __name__ == "__main__":
    app.run()
